function [model, obj, X, std_hat] = optimization(T, N, c, q, lag, framework, params, s)

    % Initialize decision variable storage
    % X columns: 1=V1, 2=p1, 3=u1, 4=s1, 5=q1, 
    %            6=V2, 7=p2, 8=u2, 9=s2, 10=q2
    X = zeros(T,10);
    std_hat = zeros(T,1); 

    % Extract streamflow time series 
    q1_s = q(:,1);
    q2_s = q(:,2);

    % Define decision variables (YALMIP)
    yalmip('clear');

    % Unit 01
    V1 = sdpvar(T,1);
    p1 = sdpvar(T,1);
    u1 = sdpvar(T,1);
    s1 = sdpvar(T,1);

    % Unit 02
    V2 = sdpvar(T,1);
    p2 = sdpvar(T,1);
    u2 = sdpvar(T,1);
    s2 = sdpvar(T,1);

    % Objective
    cons = [];
    Objective = sum((p1 + p2) - (s1 + s2));

    %% Static Constraints
    % Water Release Bounds
    cons = [cons, s(1).min_ut <= u1 <= s(1).max_ut];
    cons = [cons, s(2).min_ut <= u2 <= s(2).max_ut];

    % Feeder Capacity
    cons = [cons, 0 <= p1 <= s(1).F];
    cons = [cons, 0 <= p2 <= s(2).F];
    
    % Volume Bounds
    cons = [cons, s(1).min_V <= V1 <= s(1).max_V];
    cons = [cons, s(2).min_V <= V2 <= s(2).max_V];

    % Spill Bounds
    cons = [cons, 0 <= s1];
    cons = [cons, 0 <= s2];


    %% Build constraints
    for t = 1:T
        
        %% Forecast Inflow
        switch method
            case "det"
                disp('Deterministic forecast selected');
                q1 = q1_s(t + lag); % perfect foresight
                q2 = q2_s(t + lag);
                std_hat(t) = 0;     % no variance
            case "diu"
                disp('DIU forecast selected');
                if t <= lag
                    q1 = q1_s(t); % use prev inflow as predictor 
                    std_hat(t) = 0;
                else
                    [q1, std_hat(t)] = forecast_inflow_diu(q1_s(t), params);
                end
            case "ddu"
                disp('DDU forecast selected');
                if t <= lag
                    q1 = q1_s(t); % use prev inflow as predictor 
                    std_hat(t) = 0;
                else
                    [q1, std_hat(t)] = forecast_inflow_ddu(q1_s(t), X(t-1,5) ...
                        (X(t-1,spill2) + X(t-1,releas)), params);
            otherwise
                disp('Unknown method');
        end

        %% Time-Varying Constraints
        if t == 1 % Initial conditions
            % Mass Balance
            cons = [cons, V1(t) + u1(t) + s1(t) == s(1).V0 + q1];
            cons = [cons, V2(t) + u2(t) + s2(t) == s(2).V0 + q2];
            
            % Ramp Rates
            cons = [cons, u1(t) == s(1).min_ut];
            cons = [cons, u2(t) == s(2).min_ut];

            % Power Production
            cons = [cons, p1(t) == c*u1(t)*s(1).a*(s(1).V0^s(1).b)];
            cons = [cons, p2(t) == c*u2(t)*s(2).a*(s(2).V0^s(2).b)];
        
        else
            % Mass Balance
            cons = [cons, V1(t) + u1(t) + s1(t) == X(t-1,1) + q1];
            cons = [cons, V2(t) + u2(t) + s2(t) == X(t-1,6) + q2];
            
            % Ramp Rate Up
            cons = [cons, u1(t) <= s(1).RR_up + u1(t-1)];
            cons = [cons, u2(t) <= s(2).RR_up + u2(t-1)];

            % Ramp Rate Down
            cons = [cons, -u1(t) <= -(s(1).RR_dn + u1(t-1))];
            cons = [cons, -u2(t) <= -(s(2).RR_dn + u2(t-1))];

            % Power Production
            h1_lookup = s(1).a * X(t-1,1)^s(1).b; % previous hydraulic head
            h1_ref = map_V_to_h(h1_lookup, s(1).h_lbounds, s(1).h_rbounds, s(1).h_refvals);
            cons = [cons, p1(t) == c*u1(t)*h1_ref];

            h2_lookup = s(2).a * X(t-1,6)^s(2).b; % previous hydraulic head
            h2_ref = map_V_to_h(h2_lookup, s(2).h_lbounds, s(2).h_rbounds, s(2).h_refvals);
            cons = [cons, p2(t) == c*u2(t)*h2_ref];
                          
        end

    % Solve optimization
    options = sdpsettings('solver','gurobi','verbose',0);
    model = optimize(cons, -Objective, options);

    % Store results for time t
    X(t,1) = value(V1(t));
    X(t,2) = value(p1(t));
    X(t,3) = value(u1(t));
    X(t,4) = value(s1(t));
    X(t,5) = q1;
    X(t,6) = value(V2(t));
    X(t,7) = value(p2(t));
    X(t,8) = value(u2(t));
    X(t,9) = value(s2(t));
    X(t,10) = q2;

    end

    obj = sum(X(:,2) + X(:,7));
    fprintf('Optimization complete.\n');

    % Simulation Report
    variable_report(framework, params.season, obj, X, N)

end


function variable_report(framework, season, obj, X, N)
    sd = 4;
    fprintf('\n');
    fprintf('--- VARIABLE REPORT ---\n');
    fprintf('Segments in PWL = %d\n', N);
    fprintf('Uncertainty Framework: %s\n', framework);
    fprintf('Season: %s\n', season);
    fprintf('\n');
    fprintf('Total Generation [MWh]: %g\n', round(obj, sd+1, 'significant'));
    fprintf('Generation 01 [MWh]: %g\n', round(sum(X(:,2)), sd+1, 'significant'));
    fprintf('Generation 02 [MWh]: %g\n', round(sum(X(:,7)), sd+1, 'significant'));
    fprintf('Generation Release 01 [m3]: %g\n', round(sum(X(:,3)), sd, 'significant'));
    fprintf('Generation Release 02 [m3]: %g\n', round(sum(X(:,8)), sd, 'significant'));
    fprintf('Spill Release 01 [m3]: %g\n', floor(round(sum(X(:,4)), sd-1, 'significant')));
    fprintf('Spill Release 02 [m3]: %g\n', floor(round(sum(X(:,9)), sd-1, 'significant')));
    fprintf('\n');
end


function h_ref = map_V_to_h(h, left_bounds, right_bounds, reference_values)
    N = length(left_bounds);
    if h <= left_bounds(1)
        h_ref = reference_values(1);
    elseif h >= right_bounds(end)
        h_ref = reference_values(N);
    else
        idx = find(left_bounds <= h, 1, 'last');
        idx = min(idx, N);
        h_ref = reference_values(idx);
    end
end

function q_norm = normalize_flow(flow, mean_val, std_val)
    q_norm = (flow - mean_val)/std_val;
end

function q = rescale_flow(flow_norm, mean_val, std_val)
    q = flow_norm*std_val + mean_val;
end

function [q_hat, e] = forecast_inflow_diu(q_prev, params)
    
    % Normalize previous observed inflow
    q_prev_norm = normalize_flow(q_prev, params.inflow_mean, params.inflow_std);
    
    % Sample and scale process uncertainty with historical std
    e = randn()*params.AR_resid_std;

    % Construct inflow forecast q_t = alpha_0 + alpha_1*q_{t-1} + e
    q_hat_norm = params.AR_const + params.AR_coef*q_prev_norm + e;

    % Rescale inflow forecast
    q_hat = rescale_flow(q_hat_norm, params.inflow_mean, params.inflow_std);
end


function [q_hat, std_hat] = forecast_inflow_ddu(q_prev, q_pred_prev, outflow_prev, params)
    % Normalize
    q_prev_norm = normalize_flow(q_prev, params.inflow_mean, params.inflow_std);
    outflow_prev_norm = normalize_flow(outflow_prev, params.outflow_mean, params.outflow_std);
    q_pred_prev_norm = normalize_flow(q_pred_prev, params.inflow_mean, params.inflow_std);

    % Error term
    error_prev = abs(q_prev_norm - q_pred_prev_norm);
    norm_error_prev = (error_prev - params.error_mean)/params.error_std;

    % Variance forecast
    var_hat_norm = params.omega + params.alpha*(norm_error_prev^2) + params.gamma*outflow_prev_norm;
    std_hat_norm = sqrt(var_hat_norm);
    std_hat = std_hat_norm*params.error_std + params.error_mean;

    % Sample error
    e = randn()*std_hat;

    % Forecast inflow
    q_hat_norm = params.constant + params.coef1*q_prev_norm + params.coef2*outflow_prev_norm + e;
    q_hat = rescale_flow(q_hat_norm, params.inflow_mean, params.inflow_std);
end

