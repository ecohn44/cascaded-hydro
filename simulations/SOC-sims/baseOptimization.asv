function [model, obj, X, std_hat, V_eff] = baseOptimization(T, N, c, q, lag, scale, framework, bounds, params, s)

    % Initialize decision variable storage
    % X columns: 1=V1, 2=p1, 3=u1, 4=s1, 5=q1, 
    %            6=V2, 7=p2, 8=u2, 9=s2, 10=q2
    X = zeros(T,10);
    std_hat = zeros(T,2); 
    V_eff = zeros(T,4); % 2*n

    % Extract streamflow time series 
    q1_s = q(:,1);
    
    % Define risk level 
    eps_t = 0.95;
    n = 2; % number of units 

    % Define decision variables (YALMIP)
    yalmip('clear');


    %% Non-Anticipatory Optimization Framework 
    for t = 1:T
        
        %% Forecast Inflow
        % q_i = predicted mean inflow, stdhat_i = prdicted std dev of inflow 
        [q1, q2, std_hat(t,:)] = forecast_inflow(X, t, q1_s, lag, framework, params, s);

        %% Determine Volume Bounds
        switch bounds
            case {"det"}
                % Deterministic 
                V1_min_shift = 0;
                V1_max_shift = 0; 
                V2_min_shift = 0;
                V2_max_shift = 0;

            case {"jcc-bon"}
                % Calculate z-score 
                z = scale*norminv(1 - (1 - eps_t)/n);

                % Individual Chance Constraints
                V1_min_shift = z*std_hat(t,1);
                V1_max_shift = -z*std_hat(t,1);
                V2_min_shift = z*std_hat(t,2);
                V2_max_shift = -z*std_hat(t,2);
        end

        %% Define Decision Variables
        % Unit 01
        V1 = sdpvar(1);
        p1 = sdpvar(1);
        u1 = sdpvar(1);
        s1 = sdpvar(1);
    
        % Unit 02
        V2 = sdpvar(1);
        p2 = sdpvar(1);
        u2 = sdpvar(1);
        s2 = sdpvar(1);
    
        % Objective
        cons = [];
        Objective = sum((p1 + p2) - (s1 + s2));
    
        %% Static Constraints
        % Water Release Bounds
        cons = [cons, s(1).min_ut <= u1 <= s(1).max_ut];
        cons = [cons, s(2).min_ut <= u2 <= s(2).max_ut];
    
        % Feeder Capacity
        cons = [cons, 0 <= p1 <= s(1).F];
        cons = [cons, 0 <= p2 <= s(2).F];
    
        % Spill Bounds
        cons = [cons, 0 <= s1];
        cons = [cons, 0 <= s2];

      

        %% Time-Varying Constraints
        if t == 1 % Initial conditions
            % Mass Balance
            cons = [cons, V1 + u1 + s1 == s(1).V0 + q1];
            cons = [cons, V2 + u2 + s2 == s(2).V0 + q2];
            
            % Ramp Rates
            cons = [cons, u1 == s(1).min_ut];
            cons = [cons, u2 == s(2).min_ut];

            % Power Production
            cons = [cons, p1 == c*u1*s(1).a*(s(1).V0^s(1).b)];
            cons = [cons, p2 == c*u2*s(2).a*(s(2).V0^s(2).b)];

            % Volume Bounds (with chance constrained shift)
            cons = [cons, s(1).min_V + V1_min_shift <= V1 <= s(1).max_V + V1_max_shift];
            cons = [cons, s(2).min_V + V2_min_shift <= V2 <= s(2).max_V + V2_max_shift];
        
        else
            % Mass Balance
            cons = [cons, V1 + u1 + s1 == X(t-1,1) + q1];
            cons = [cons, V2 + u2 + s2 == X(t-1,6) + q2];
            
            % Ramp Rates
            cons = [cons, s(1).RR_dn <= u1 - X(t-1,3) <= s(1).RR_up];
            cons = [cons, s(2).RR_dn <= u2 - X(t-1,8) <= s(2).RR_up];

            % Power Production
            h1_lookup = s(1).a * X(t-1,1)^s(1).b; % previous hydraulic head
            h1_ref = map_V_to_h(h1_lookup, s(1).h_lbounds, s(1).h_rbounds, s(1).h_refvals);
            cons = [cons, p1 == c*u1*h1_ref];

            h2_lookup = s(2).a * X(t-1,6)^s(2).b; % previous hydraulic head
            h2_ref = map_V_to_h(h2_lookup, s(2).h_lbounds, s(2).h_rbounds, s(2).h_refvals);
            cons = [cons, p2 == c*u2*h2_ref];
                          
        end

    % Solve optimization
    options = sdpsettings('solver','gurobi','verbose',0);
    model = optimize(cons, -Objective, options);

    % Abort early on infeasible/numerical issues
    if model.problem ~= 0
        error('Solver issue at t=%d: %s', t, yalmiperror(model.problem));
    end

    % Store results for time t
    X(t,1) = value(V1);
    X(t,2) = value(p1);
    X(t,3) = value(u1);
    X(t,4) = value(s1);
    X(t,5) = q1;
    X(t,6) = value(V2);
    X(t,7) = value(p2);
    X(t,8) = value(u2);
    X(t,9) = value(s2);
    X(t,10) = q2;

    end

    obj = sum(X(:,2) + X(:,7)); % Total power production 
    fprintf('Optimization complete.\n');

    % Simulation Report
    variable_report(framework, params.season, obj, X, N)

end


function variable_report(framework, season, obj, X, N)
    sd = 4;
    fprintf('\n');
    fprintf('--- VARIABLE REPORT ---\n');
    fprintf('Segments in PWL = %d\n', N);
    fprintf('Uncertainty Framework: %s\n', framework);
    fprintf('Season: %s\n', season);
    fprintf('\n');
    fprintf('Total Generation [MWh]: %g\n', round(obj, sd+1, 'significant'));
    fprintf('Generation 01 [MWh]: %g\n', round(sum(X(:,2)), sd+1, 'significant'));
    fprintf('Generation 02 [MWh]: %g\n', round(sum(X(:,7)), sd+1, 'significant'));
    fprintf('Generation Release 01 [m3]: %g\n', round(sum(X(:,3)), sd, 'significant'));
    fprintf('Generation Release 02 [m3]: %g\n', round(sum(X(:,8)), sd, 'significant'));
    fprintf('Spill Release 01 [m3]: %g\n', floor(round(sum(X(:,4)), sd-1, 'significant')));
    fprintf('Spill Release 02 [m3]: %g\n', floor(round(sum(X(:,9)), sd-1, 'significant')));
    fprintf('\n');
end


function h_ref = map_V_to_h(h, left_bounds, right_bounds, reference_values)
    N = length(left_bounds);
    if h <= left_bounds(1)
        h_ref = reference_values(1);
    elseif h >= right_bounds(end)
        h_ref = reference_values(N);
    else
        idx = find(left_bounds <= h, 1, 'last');
        idx = min(idx, N);
        h_ref = reference_values(idx);
    end
end


function [q1, q2, std_hat] = forecast_inflow(X, t, q1_s, lag, framework, params, s)
    
    std_hat = [0, 0];
    
    % Calculate previous release
    if t <= lag 
        X1_prev = s(1).min_ut; % min flow
    else 
        X1_prev = X(t-lag,3) + X(t-lag,4);
    end 
    
    %% Forecast Upstream Inflow
    switch framework
        case "det"
            % Calculate Q1
            q1 = q1_s(t + lag); % perfect foresight
            
            % Calculate Q2
            q2 = X1_prev; % lagged upstream release

        case "diu"
            % Forecast Q1
            [q1, std_hat(1)] = forecast_inflow_diu(q1_s(t), params); %q1_s is lagged historical inflow
            
            % Forecast Q2
            % (TEMP) will use q2_s(t) "local flow" in Columbia River
            [q2, std_hat(2)] = forecast_inflow_diu(X1_prev, params);
           
        
        case "ddu"
            if t <= lag
                % Forecast Q1
                [q1, std_hat(1)] = forecast_inflow_diu(q1_s(t), params); %q1_s is lagged historical inflow
                
                % Forecast Q2
                % (TEMP) will use q2_s(t) "local flow" in Columbia River
                [q2, std_hat(2)] = forecast_inflow_diu(X1_prev, params);
            else
                % Forecast Q1 (DIU - no upstream to condition on)
                [q1, std_hat(1)] = forecast_inflow_diu(q1_s(t), params);
               
                % Forecast Q2
                % (TEMP) will use q2_s(t) "local flow" for arg1
                [q2, std_hat(2)] = forecast_inflow_ddu(X1_prev, X(t-lag,10), X1_prev, params);
            end
    end
end

function [q_hat, std_hat] = forecast_inflow_diu(q_prev, params)

    % Construct inflow forecast q_t = alpha_0 + alpha_1*q_{t-1}
    q_hat = params.AR_const + params.AR_coef*q_prev;

    % Extract (normalized) standard deviation 
    std_hat = params.AR_std;
end


function [q_hat, std_hat] = forecast_inflow_ddu(q_prev_norm, q_pred_prev_norm, outflow_prev_norm, params)

    % Calculate previous error term
    norm_error_prev = abs(q_prev_norm - q_pred_prev_norm);
    
    % Forecast conditional variance using GARCH-X
    var_hat_norm = params.omega + params.alpha*(norm_error_prev^2) + params.gamma*outflow_prev_norm;
    std_hat = sqrt(var_hat_norm);
    
    % Construct inflow forecast from OLS model
    q_hat = params.constant + params.coef1*q_prev_norm + params.coef2*outflow_prev_norm;
  
end

