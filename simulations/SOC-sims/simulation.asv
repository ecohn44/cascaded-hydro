%% Author: Eliza Cohn
% Date: February 2026
% Description: Main driver for cascaded hydropower simulations 
% Paper: EXPLICIT RISK ALLOCATION FOR CASCADED HYDROELECTRIC SYSTEMS UNDER EXTREME EVENTS

tic; 
clear; clc; close all;

addpath('/Library/gurobi1202/macos_universal2/matlab');
addpath(genpath('/Users/elizacohn/Documents/YALMIP-master'))

% Add shared functions to file path 
thisFilePath = fileparts(mfilename('fullpath'));
addpath(genpath(fullfile(thisFilePath, '..', 'functions')));

%% ========================================================================
% SECTION 1: DATA LOADING AND PARAMETER DEFINITION
% ========================================================================

% Toggle for creating folder and plotting
make_dir = false;
printplot = false; 
save_mat = true; 
save_streamflow = false;

% Static parameters 
eta = .9;           % efficiency of release-energy conversion
rho_w = 1000;       % density of water [kg/m^3]
g = 9.8;            % acceleration due to gravity [m/s^2]
c = 1;              % power prod coefficient (c = eta*rho_w*g/3.6e9)
N = 40;             % number of sub-intervals for piecewise linear approx
n = 3;              % number of units in cascaded network 
eps = 0.05;         % risk tolerance 

% Load inflow data 
[modelparams, sysparams, seasonparams] = dataload(n, N);

%% ========================================================================
% SECTION 2: SIMULATION SETTINGS
% ========================================================================

% Initialize settings (season, drought type, lin approx, uncertainty, sln alg, volume price)
simSettings = initSimSettings("wet", "ramp", "pwl", "det", "jcc-bon", "none");

% Extract forecasting coefficients 
modelparams = modelparams(strcmp({modelparams.season}, simSettings.season));

% Extract event scenario simulation mode
seasonparams = seasonparams(strcmp({seasonparams.mode}, simSettings.scenario));

% Set baseline flow based on season
if simSettings.season == "dry"
    seasonparams.q0 = 0.9*sysparams(1).max_ut;
    [sysparams.V0] = deal(0.1);
elseif simSettings.season == "wet"
    seasonparams.q0 = 0.3*sysparams(1).max_ut;
    [sysparams.V0] = deal(0.2);
else
    seasonparams.q0 = sysparams(1).max_ut;
end

% Date range settings 
D = 3.5;                      % Simulation duration in days
T = 24*D;                     % Number of simulation hours
lag = 3;                      % Travel time between units (hrs)

% Load price data
LMP = ones(T, n); % simulatePrice(T, n, true);

% Create path to store results  
if simSettings.bounds == "jcc-ssh"
    results_dir = "./resultsSSH/" + modelparams.season + "/";
elseif simSettings.bounds == "jcc-bon"
    results_dir = "./resultsBonferroni/" + modelparams.season + "/";
else 
    warning('Results directory does not exist');
end 

fprintf('Data loading complete.\n');

%% ========================================================================
% SECTION 3A: STREAMFLOW BEHAVIOR
% ========================================================================

% Matrix for local streamflow 
q = zeros(T+lag, n);

% Cascaded drought parameters
baseStreamflow = seasonparams;
severityScales = makeSeverityScales(n);    

% Simulate scaled events 
for i = 1:n
    dp    = baseStreamflow; 

    % Apply scaling to each inflow profile 
    scale = 1; % severityScales(i);

    if strcmpi(dp.mode, 'extended')
        dp.amp1 = baseStreamflow.amp1 * scale;
    end

    dp.shiftMult = i - 1;

    q(:,i) = scenarioSimulator(T, lag, simSettings.season, dp.mode, dp);
end

% Plot streamflow profiles
plotStreamflows(q)

% Offline DIU covariance and std devs
sigma_diu                 = modelparams.AR_std*ones(n,1);   % n×1 std devs
modelparams.sigma_diu     = sigma_diu;        
modelparams.Sigma_diu     = diag(sigma_diu.^2);             % n×n covariance (DIU)

% Offline correlation matrix
modelparams.Rcorr         = estimateR(T, n, lag, q, modelparams); % n×n correlation

% Check PD-ness for covariance matrix 
if isPD(modelparams.Sigma_diu)
    disp('Σ is PD');
else
    warning('Σ is NOT PD');
end 

% Check PD-ness for correlation matrix 
if isPD(modelparams.Rcorr)
    disp('R is PD');
else
    warning('R is NOT PD');
end 

%% ========================================================================
% SECTION 4: OPTIMIZATION FRAMEWORK
% ========================================================================

% Scaling factor for chance-constrained bounds
scale = 1;

[model, obj, X, std_hat, V_eff, phi_vals, alpha_vals] = genOptimization(T, N, c, q, LMP, lag, scale, ...
    simSettings.framework, simSettings.bounds, modelparams, sysparams, eps, simSettings.volPrice);


%% ========================================================================
% SECTION 5: PLOTTING
% ========================================================================

% Make plot directory for current simulation run 
if make_dir
    dir_path = "./plots/";
    stamp = datestr(now,'mm-dd-yyyy HH.MM.SS');
    path = fullfile(dir_path, stamp + " " + simSettings.season + " " ...
        + simSettings.framework + ...
        " T=" + string(T));
    mkdir(path)
end

% Plot simulation behavior for all units
simPlots(path, X, sysparams, T, c, printplot);

% Plot SSH algorithm behavior 
if simSettings.bounds == "jcc-ssh"
    plotSSH(phi_vals, alpha_vals, eps, upper(simSettings.framework));
end 

% Save results 
if save_mat
    for i = 1:numel(sysparams)
        sp = sysparams(i);
        fname = sprintf('results_unit%d_%s.mat', ...
            sp.unit, lower(simSettings.framework));
    
        season = simSettings.season;  
    
        save(fullfile(results_dir, fname), ...
            'X', 'V_eff', 'std_hat', 'q', 'sysparams', ...
            'T', 'c', 'lag', 'season', '-v7');
    end
end 

if save_streamflow
    q_sim = zeros(T, n);
    for i = 1:n
        base = 5*(i-1);
        q_sim(:, i)  = X(:, base+5);
    end
    save('floodFlow.mat','q_sim')
end

fprintf('Simulation complete.\n');
fprintf('Total runtime: %.2f seconds.\n', toc);


function plotStreamflows(q)
    % q: T+lag x n matrix, each column is a streamflow time series

    [T, n] = size(q);
    t = (1:T)';        

    figure;
    for i = 1:n
        subplot(n, 1, i);
        plot(t, q(:, i), 'LineWidth', 3);
        ylim([0 1.1*max(q(:,i))]); 
        xlim([1, T]);
        
        ylabel(sprintf('q_%d', i), 'FontSize', 16);
        set(gca, 'FontSize', 16); 

        if i == 1
            title('Streamflow Time Series', 'FontSize', 20);
        end
        if i == n
            xlabel('Time (hour)', 'FontSize', 16);
        else
            set(gca, 'XTickLabel', []);  % hide x labels for middle plots
        end

        grid on;
    end
end


function severityScales = makeSeverityScales(N)

    % Split into two halves
    half = floor(N/2);         % first half length
    rest = N - half;           % second half length
    
    % First half: 1.0, 0.9, 0.8, ..., decreasing by 0.1
    firstHalf  = 1.0 - 0.1*(0:half-1);
    
    % Second half: 0.1, 0.2, 0.3, ..., increasing by 0.1
    secondHalf = 0.1*(1:rest);
    
    % Combine
    severityScales = [firstHalf flip(secondHalf)];
end


function tf = isPD(A)
    % Symmetrize first
    A = (A + A')/2;      
    [~,p] = chol(A);
    tf = (p == 0);        % true if PD
end

function R = estimateR(T, n, lag, q, m)

    alpha0 = m.AR_const;
    alpha1 = m.AR_coef;

    % Preallocate forecast and residuals
    q_hat = nan(T, n);
    E     = nan(T, n);
    
    % AR(1) forecast (q already starts at lag)
    for t = 1:T
        % Forecast streamflow based on lagged observation 
        q_hat(t,:) = alpha0 + alpha1*q(t,:);

        % Calculate forecast error based on actual observation 
        E(t,:)     = q(t+lag,:) - q_hat(t,:);
    end

    % Compute correlation of forecast errors
    R = corr(E, 'Rows', 'complete');

end
