%% Author: Eliza Cohn
% Date: February 2026
% Description: Main driver for cascaded hydropower simulations 
% Paper: EXPLICIT RISK ALLOCATION FOR CASCADED HYDROELECTRIC SYSTEMS UNDER EXTREME EVENTS

tic; 
clear; clc; close all;

addpath('/Library/gurobi1202/macos_universal2/matlab');
addpath(genpath('/Users/elizacohn/Documents/YALMIP-master'))

% Add shared functions to file path 
thisFilePath = fileparts(mfilename('fullpath'));
addpath(genpath(fullfile(thisFilePath, '..', 'functions')));

%% ========================================================================
% SECTION 1: DATA LOADING AND PARAMETER DEFINITION
% ========================================================================

% Toggle for creating folder and plotting
make_dir = false;
printplot = false; 
save_mat = true; 
save_streamflow = true;

% Static parameters 
eta = .9;           % efficiency of release-energy conversion
rho_w = 1000;       % density of water [kg/m^3]
g = 9.8;            % acceleration due to gravity [m/s^2]
c = 1;              % power prod coefficient (c = eta*rho_w*g/3.6e9)
N = 40;             % number of sub-intervals for piecewise linear approx
n = 3;              % number of units in cascaded network 
eps = 0.05;         % risk tolerance 

% Load inflow data 
[modelparams, sysparams, seasonparams] = dataload(n, N);

%% ========================================================================
% SECTION 2: SIMULATION SETTINGS
% ========================================================================

% Initialize settings (season, drought type, lin approx, uncertainty, sln alg, volume price)
simSettings = initSimSettings("dry", "extended", "pwl", "det", "jcc-ssh", "none");

% Extract forecasting coefficients 
modelparams = modelparams(strcmp({modelparams.season}, simSettings.season));

% Extract event scenario simulation mode
seasonparams = seasonparams(strcmp({seasonparams.mode}, simSettings.scenario));

% Set baseline flow based on season
if simSettings.season == "dry"
    seasonparams.q0 = 0.9*sysparams(1).max_ut;
    [sysparams.V0] = deal(0.1);
    D = 3.5;        % Simulation duration in days
elseif simSettings.season == "wet"
    seasonparams.q0 = sysparams(1).max_ut;
    [sysparams.V0] = deal(0.8);
    D = 14;         % Simulation duration in days
else
    seasonparams.q0 = sysparams(1).max_ut;
end

% Date range settings            
T = 24*D;                    % Number of simulation hours
lag = 1;                     % Travel time between units (hrs)

% Load price data
LMP = ones(T, n); % simulatePrice(T, n, true);

% Create path to store results  
if simSettings.bounds == "jcc-ssh"
    results_dir = "./resultsSSH/" + modelparams.season + "/";
elseif simSettings.bounds == "jcc-bon"
    results_dir = "./resultsBonferroni/" + modelparams.season + "/";
else 
    warning('Results directory does not exist');
end 

fprintf('Data loading complete.\n');

%% ========================================================================
% SECTION 3A: STREAMFLOW BEHAVIOR
% ========================================================================

% Matrix for local streamflow 
q = zeros(T+lag, n);

% Cascaded drought parameters
baseStreamflow = seasonparams;
severityScales = makeSeverityScales(n);    

% Simulate scaled events 
for i = 1:n
    dp    = baseStreamflow; 

    if strcmpi(dp.mode, 'extended')
        dp.amp1 = baseStreamflow.amp1;
    end

    dp.shiftMult = i - 1;

    q(:,i) = scenarioSimulator(T, lag, simSettings.season, dp.mode, dp);
end

% Simulated metrics
scale.mu_q = mean(q(:,1));
scale.std_q = std(q(:,1));
scale.H0 = 9.5;
scale.dH_m = 1.2; 

% Plot streamflow profiles
plotStreamflows(q, scale)

% Offline DIU covariance and std devs
sigma_diu                 = modelparams.AR_std*ones(n,1);   % n×1 std devs
modelparams.sigma_diu     = sigma_diu;        
modelparams.Sigma_diu     = diag(sigma_diu.^2);             % n×n covariance (DIU)

% Offline correlation matrix
modelparams.Rcorr         = estimateR(T, n, lag, q, modelparams); % n×n correlation

% Check PD-ness for covariance matrix 
if isPD(modelparams.Sigma_diu)
    disp('Σ is PD');
else
    warning('Σ is NOT PD');
end 

% Check PD-ness for correlation matrix 
if isPD(modelparams.Rcorr)
    disp('R is PD');
else
    warning('R is NOT PD');
end 

%% ========================================================================
% SECTION 4: OPTIMIZATION FRAMEWORK
% ========================================================================

[model, obj, X, std_hat, V_eff, phi_vals, alpha_vals] = genOptimization(T, N, c, q, LMP, lag, ...
    simSettings.framework, simSettings.bounds, modelparams, sysparams, eps, simSettings.volPrice);


%% ========================================================================
% SECTION 5: PLOTTING
% ========================================================================

% Make plot directory for current simulation run 
if make_dir
    dir_path = "./plots/";
    stamp = datestr(now,'mm-dd-yyyy HH.MM.SS');
    path = fullfile(dir_path, stamp + " " + simSettings.season + " " ...
        + simSettings.framework + ...
        " T=" + string(T));
    mkdir(path)
end

% Plot simulation behavior for all units
simPlots(path, X, sysparams, T, c, printplot);

% Plot SSH algorithm behavior 
if simSettings.bounds == "jcc-ssh"
    plotSSH(phi_vals, alpha_vals, eps, upper(simSettings.framework));
end 

% Save results 
if save_mat
    for i = 1:numel(sysparams)
        sp = sysparams(i);
        fname = sprintf('results_unit%d_%s.mat', ...
            sp.unit, lower(simSettings.framework));
    
        season = simSettings.season;  
    
        save(fullfile(results_dir, fname), ...
            'X', 'V_eff', 'std_hat', 'q', 'sysparams', ...
            'T', 'c', 'lag', 'season', '-v7');
    end
end 

if save_streamflow
   
    q_save = q(1+lag:T+lag, :);

    save('floodFlow.mat', 'q_save')
end

fprintf('Simulation complete.\n');
fprintf('Total runtime: %.2f seconds.\n', toc);


function plotStreamflows(q, scale)

% Inputs:
%   q     : T x n matrix (each column is a normalized streamflow time series)
%   scale : struct with fields:
%           mu_Q, std_Q   (physical mean/std in m^3/s)
%           mu_q, std_q   (normalized mean/std on 0-1 scale)

    [T, n] = size(q);
    t = (1:T)';

    % Rescale streamflow
    alpha_q = scale.std_Q / scale.std_q;                 % unit conversion slope
    Q = scale.mu_Q + alpha_q * (q - scale.mu_q);         % T x n in m^3/s

    % Plot Settings
    fs_ax   = 18;
    fs_lab  = 18;
    lw      = 3;
    col     = [0 0.2 0.6];   % Dark blue

    % Unified y-limits 
    Qmax = max(Q, [], 'all');
    ylo  = 0;
    yhi  = 1.05 * Qmax;

    % Figure
    figure('Color','w');
    tl = tiledlayout(n, 1, 'TileSpacing','compact', 'Padding','compact');

    for i = 1:n
        ax = nexttile; hold(ax, 'on');

        plot(ax, t, Q(:, i), 'LineWidth', lw, 'Color', col);

        % axes limits
        xlim(ax, [1, T]);
        ylim(ax, [ylo, yhi]);

        % labels
        ylabel(ax, sprintf('Q_%d (m^3/s)', i), 'FontSize', fs_lab);

        % typography
        set(ax, 'FontSize', fs_ax);

        % grid
        grid(ax, 'on');
        set(ax, 'YGrid','on', 'XGrid','off');

        % show x label only on bottom panel
        if i == n
            xlabel(ax, 'Time (hours)', 'FontSize', fs_lab);
        else
            set(ax, 'XTickLabel', []);
        end
    end
end


function severityScales = makeSeverityScales(N)

    % Split into two halves
    half = floor(N/2);         % first half length
    rest = N - half;           % second half length
    
    % First half: 1.0, 0.9, 0.8, ..., decreasing by 0.1
    firstHalf  = 1.0 - 0.1*(0:half-1);
    
    % Second half: 0.1, 0.2, 0.3, ..., increasing by 0.1
    secondHalf = 0.1*(1:rest);
    
    % Combine
    severityScales = [firstHalf flip(secondHalf)];
end


function tf = isPD(A)
    % Symmetrize first
    A = (A + A')/2;      
    [~,p] = chol(A);
    tf = (p == 0);        % true if PD
end

function R = estimateR(T, n, lag, q, m)

    alpha0 = m.AR_const;
    alpha1 = m.AR_coef;

    % Preallocate forecast and residuals
    q_hat = nan(T, n);
    E     = nan(T, n);
    
    % AR(1) forecast (q already starts at lag)
    for t = 1:T
        % Forecast streamflow based on lagged observation 
        q_hat(t,:) = alpha0 + alpha1*q(t,:);

        % Calculate forecast error based on actual observation 
        E(t,:)     = q(t+lag,:) - q_hat(t,:);
    end

    % Compute correlation of forecast errors
    R = corr(E, 'Rows', 'complete');

end
