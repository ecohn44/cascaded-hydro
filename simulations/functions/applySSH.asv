function [cons_out, x_sol, phi_val, alpha_vals] = applySSH(cons, vars, t, X_prev, q_mean, Sigma_q, ...
        x_slater, p_target, s, Objective, options)

    % Sequential Supporting Hyperplane (SSH) step for n units
    %
    % Inputs:
    %   vars       : struct of decision variables for all units at time t
    %   X_prev     : array of solutions derived at previous time step
    %   s          : struct of system parameters
    %   q_mean     : array of inflows into each unit
    %   Sigma_q    : covariance matrix of inflows
    %
    % Decision stacking for x:
    %   x = [V1,p1,u1,s1, V2,p2,u2,s2, ..., Vn,pn,un,sn]'

    fprintf('SSH (t=%d)\n', t);

    % Number of units
    n_units = numel(vars.V);
    dim_x   = 4 * n_units;

    %% STEP 1: Solve the LP 
    optimize(cons, -Objective, options);
    obj_val = value(Objective);

    % Build current solution vector xk from YALMIP values
    xk = zeros(dim_x, 1);
    for i = 1:n_units
        base = 4*(i-1);
        xk(base+1) = value(vars.V(i));
        xk(base+2) = value(vars.p(i));
        xk(base+3) = value(vars.u(i));
        xk(base+4) = value(vars.s(i));
    end

    % Evaluate reliability (CDF of joint normals for inflow)
    phi_k = compute_phi_from_x(xk, q_mean, Sigma_q, X_prev, s);

    % fprintf('   SSH base solve: obj=%.4e, φ=%.4f, target=%.4f\n', obj_val, phi_k, p_target);

    % Check if unconstrained solution is feasible already (phi(x) ≥ p)
    if phi_k < p_target
        fprintf('Solution xk doesnt meet reliability criteria (φ=%.4f)\n', phi_k);
    else % phi_k >= p_target
        fprintf('Solution xk meets reliability criteria (φ=%.4f ≥ %.4f)\n', phi_k, p_target);
        cons_out = cons; 
        x_sol    = xk; 
        phi_val  = phi_k;
        alpha_vals = zeros(n_units,1);  % no reallocation needed
        return;
    end

    %% STEP 2: Interpolation 
    % lower bound: phi(xk) from unconstrained LP
    phi_low  = phi_k;  
    
    % upper bound: phi(xs) from slater point (feasible not optimal)
    phi_high = compute_phi_from_x(x_slater, q_mean, Sigma_q, X_prev, s);
    
    % Check to make sure slater point satifies reliability criteria 
    if phi_high < p_target
        warning('Slater point infeasible: φ(x_slater)=%.4f < p_target=%.4f\n', ...
               phi_high, p_target);
    else 
        fprintf('Slater point feasible: φ(x_slater)=%.4f >= p_target=%.4f\n', ...
               phi_high, p_target);
    end

    % Boundaries for lambda 
    lam_low = 0; lam_high = 1;
    lam      = 0.5;     % init lambda_0
    phi_star = phi_low; % init phi(xk*)

    % Bisection search algorithm 
    for bis = 1:25
        lam = 0.5 * (lam_low + lam_high);
        x_star  = (1 - lam) * xk + lam * x_slater;
        phi_star = compute_phi_from_x(x_star, q_mean, Sigma_q, X_prev, s);

        if phi_star < p_target
            lam_low  = lam; 
            phi_low  = phi_star;
        else
            lam_high = lam; 
            phi_high = phi_star;
        end

        if phi_star > p_target % abs(phi_star - p_target) < 1e-4 % solution tol
            break;
        end
    end

    fprintf('   Found boundary point: λ*=%.3f, φ*=%.4f\n', lam, phi_star);

    
    %% STEP 3: Add supporting hyperplane at x_star
    
    % Gradient vector initialization 
    g   = zeros(dim_x,1);
    alpha_vals = zeros(n_units,1);
    weights    = zeros(n_units,1);

    % Calculate gradient via finite differences 
    for i = 1:n_units
        
        % Store index for u_i 
        j = 4*(i-1) + 3; 

        % Pick an epsilon scaled to decision var
        eps_j = 1e-6 * max(1, abs(x_star(j)));  
        e     = zeros(dim_x,1); 
        e(j)  = eps_j;

        % Calculate gradient 
        f1 = compute_phi_from_x(x_star + e, q_mean, Sigma_q, X_prev, s);
        f2 = compute_phi_from_x(x_star - e, q_mean, Sigma_q, X_prev, s);
        g(j) = (f1 - f2) / (2 * eps_j);

        % Calculate gradient norm for u_i
        weights(i) = abs(g(j));
    end

    % Normalize and store gradient weights 
    total_w = sum(weights);
    if total_w > 0
        alpha_vals = weights / total_w;
    end

    fprintf('   Gradient (w_i): ');
    fprintf('%.2f ', g); fprintf('\n');

    fprintf('   Slack allocation (α_i): ');
    fprintf('%.2f ', alpha_vals);
    fprintf('(sum=%.2f)\n', sum(alpha_vals));

    % Norm of gradient
    grad_norm = norm(g);
    
    % Add cut if gradient is non-trivial 
    if grad_norm < 1e-9
        fprintf('   Gradient ≈ 0 (flat φ region) → skipping cut\n');
    else
        % Build linear form ∇φ(x*)ᵀ (x - x*) ≤ 0  →  ∑ g_i x_i ≥ g^T x*
        lhs = 0;
        for i = 1:n_units
            base = 4*(i-1);
            lhs = lhs ...
                + g(base+1) * vars.V(i) ...
                + g(base+2) * vars.p(i) ...
                + g(base+3) * vars.u(i) ...
                + g(base+4) * vars.s(i);
        end
        rhs = g.' * x_star;

        cons = [cons, lhs >= rhs];

        fprintf('   Added SSH cut: ||∇φ||=%.3e, φ*=%.4f, target=%.4f\n', ...
                 norm(g), phi_star, p_target);
    end


    %% STEP 4: Re-solve LP with the new cut
    optimize(cons, -Objective, options);
    obj_val2 = value(Objective);

    % Updated solution
    xk = zeros(dim_x, 1);
    for i = 1:n_units
        base = 4*(i-1);
        xk(base+1) = value(vars.V(i));
        xk(base+2) = value(vars.p(i));
        xk(base+3) = value(vars.u(i));
        xk(base+4) = value(vars.s(i));
    end

    phi_k = compute_phi_from_x(xk, q_mean, Sigma_q, X_prev, s);
    if phi_k < p_target
        warning('Solution point infeasible: φ(x_k)=%.4f < p_target=%.4f\n', ...
               phi_k, p_target);
    end

    fprintf('   After cut: obj=%.4e, φ(x)=%.4f (Δφ=%.3e)\n', ...
            obj_val2, phi_k, phi_k - phi_star);

    % Return outputs
    cons_out  = cons; 
    x_sol     = xk; 
    phi_val   = phi_k;
end


function phi = compute_phi_from_x(x, q_mean_vec, Sigma_q, X_prev, s)

    n_units = numel(s);

    q_low  = zeros(n_units,1);
    q_high = zeros(n_units,1);

    % Calculate inflow bounds from mass balance equation 
    for i = 1:n_units
        
        % Extract previous volume for unit i
        baseX   = 5*(i-1);
        V_prev  = X_prev(baseX + 1);   % V_i at t-1

        % Extract outflow decision for unit i during initialization 
        base    = 4*(i-1);
        u_i     = x(base + 3);
        s_i     = x(base + 4);

        % Calculate storage-implied inflow band for unit i
        q_low(i)  = s(i).min_V - V_prev + u_i + s_i;
        q_high(i) = s(i).max_V - V_prev + u_i + s_i;
    end

    % disp(Sigma_q)

    % Deterministic special case 
    if all(abs(Sigma_q(:)) < 1e-12)
        % Probability is 1 if mu in [q_low, q_high], else 0
        in_band = all(q_mean_vec >= q_low' & q_mean_vec <= q_high');
        phi = double(in_band);
        return;
    end

    % Multivariate normal probability that q lies in [q_low, q_high]
    phi = mvncdf(q_low', q_high', q_mean_vec, Sigma_q);
end
